% ============================================================================
% TP Sistemas de Computacion - Informe completo
% Indice: GINI + Python + C (32 bits) + Ensamblador NASM + GDB
% ============================================================================
\documentclass[a4paper,12pt]{article}
\catcode`\_=12

% ----------------------- Paquetes básicos ----------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{float}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage[hidelinks]{hyperref}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{hyperref}


% ----------------------- Configuracion global ------------------------------
\geometry{margin=2.5cm}
\graphicspath{{images/}}
\pagestyle{fancy}
\fancyhf{}
\lhead{Boot}
\rhead{TP Sistemas de Computacion}
\cfoot{\thepage}

% ----------------------- Listings ------------------------------------------
\lstdefinelanguage{NASM}{
  morekeywords={section,global,extern,fld,fistp,add,leave,ret,push,mov,sub},
  sensitive=true,
  morecomment=[l]{;},
  morestring=[b]",
}
\lstset{
  basicstyle=\ttfamily\small,
  numberstyle=\tiny,
  numbers=left,
  stepnumber=1,
  frame=single,
  captionpos=b,
  keywordstyle=\color{blue},
  commentstyle=\itshape\color{gray!70},
}

% Añadimos configuración para C
\lstdefinelanguage{C}{
  morekeywords={EFI_STATUS,CHAR16,UINTN,UINT32,EFI_GUID},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}
\lstset{language=C}

% ----------------------- Metadatos del documento ---------------------------
\title{\textbf{TP Sistemas de Computación}\\\large Práctico: UEFI}
\author{Alumno: Nombre Apellido \\ Materia: Sistemas de Computación \\ Comisión: XX}
\date{\today}

% ----------------------- Inicio del documento ------------------------------
\begin{document}

\maketitle
\thispagestyle{empty}
\clearpage
\tableofcontents
\clearpage

\section{Introducción}
En este trabajo práctico se aborda la arquitectura UEFI, sus diferencias fundamentales con el antiguo BIOS, la forma de interactuar con ella tanto a nivel usuario como a nivel desarrollador, y se muestra un ejemplo de llamada a una de sus funciones de Runtime Services.

\section{¿Qué es UEFI?}
UEFI (\emph{Unified Extensible Firmware Interface}) es la especificación que define una interfaz de software moderna entre el firmware de la plataforma (antes BIOS) y el sistema operativo. A diferencia del BIOS tradicional, UEFI:
\begin{itemize}[noitemsep]
  \item Está escrito en C y opera en modo 32 o 64 bits.
  \item Ofrece controladores propios para hardware básico (red, almacenamiento, gráficos).
  \item Soporta particiones GPT (superando el límite de 2\,TB de MBR).
  \item Incorpora un entorno seguro (\emph{Secure Boot}) y gestión de clave pública.
  \item Se organiza en \emph{Boot Services} (solo durante el arranque) y \emph{Runtime Services} (disponibles para el SO tras el arranque).
\end{itemize}

\subsection{¿Cómo puedo usarlo?}
\subsubsection{Como usuario final}
\begin{enumerate}[noitemsep]
  \item Durante el arranque, pulsar la tecla indicada (DEL, F2, F10, F12, ESC) para entrar en el \emph{Setup} de UEFI.
  \item Desde allí se puede:
    \begin{itemize}[noitemsep]
      \item Cambiar el orden de arranque.
      \item Habilitar/deshabilitar \emph{Secure Boot}.
      \item Ajustar parámetros de hardware (incluido overclocking).
    \end{itemize}
  \item En sistemas UNIX-like, utilidades como \texttt{efibootmgr} permiten listar y modificar entradas UEFI desde el sistema operativo.
\end{enumerate}

\subsubsection{Como desarrollador / cargador de arranque}
Al escribir un \emph{bootloader} o sistema operativo \emph{bare-metal} para UEFI:
\begin{enumerate}[noitemsep]
  \item El firmware UEFI pasa al cargador una estructura \texttt{EFI\_SYSTEM\_TABLE}, que incluye punteros a:
    \begin{itemize}[noitemsep]
      \item \texttt{BootServices} (servicios disponibles solo durante el arranque).
      \item \texttt{RuntimeServices} (servicios que perduran tras el \emph{ExitBootServices}).
    \end{itemize}
  \item Para invocar una rutina UEFI, se localiza el puntero en la tabla de servicios y se llama en C/C++ correctamente, respetando la ABI UEFI (registro de parámetros, alineamiento, etc.).
\end{enumerate}

\subsection{Ejemplo de llamada a función UEFI}

Una aplicación UEFI puede acceder a las variables persistentes almacenadas en la NVRAM (Non-Volatile RAM) mediante los \emph{Runtime Services}, que son parte del entorno estándar definido por la especificación UEFI. A continuación, se muestra un ejemplo de cómo utilizar la función \texttt{GetVariable} para leer la variable global \texttt{BootOrder}, la cual contiene el orden de dispositivos para el arranque del sistema. Esta función está documentada en la sección correspondiente de la especificación oficial UEFI.

\begin{lstlisting}[caption={Lectura de la variable \texttt{BootOrder} mediante \texttt{GetVariable}}, label={lst:getvariable}]
#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Library/UefiBootServicesTableLib.h>

// GUID estandar para variables globales definidas por UEFI
extern EFI_GUID gEfiGlobalVariableGuid;

EFI_STATUS
LeerBootOrder(VOID)
{
    EFI_STATUS status;
    CHAR16 *VariableName = L"BootOrder";
    UINTN DataSize = sizeof(UINT16) * 16; // espacio para hasta 16 entradas
    UINT16 BootOrder[16];
    UINT32 Attributes;

    status = gST->RuntimeServices->GetVariable(
        VariableName,
        &gEfiGlobalVariableGuid,
        &Attributes,
        &DataSize,
        BootOrder
    );

    if (EFI_ERROR(status)) {
        Print(L"Error al leer BootOrder: %r\n", status);
        return status;
    }

    // Aqui se puede procesar el contenido de BootOrder...
    return EFI_SUCCESS;
}
\end{lstlisting}

En este ejemplo:

\begin{itemize}
  \item \texttt{GetVariable} es la función que permite acceder al valor de una variable definida por el firmware.
  \item \texttt{gST} es un puntero global a la tabla del sistema UEFI (\texttt{EFI_SYSTEM_TABLE}), desde la cual se accede a los \emph{Runtime Services}.
  \item \texttt{gEfiGlobalVariableGuid} identifica el espacio de nombres reservado para variables estándar UEFI.
  \item \texttt{Attributes}, \texttt{DataSize} y \texttt{BootOrder} son parámetros de salida que reciben respectivamente los atributos, el tamaño en bytes y los datos de la variable.
\end{itemize}

\noindent Para más detalles, se puede consultar la documentación oficial en: \href{https://uefi.org/specs/UEFI/2.10/08_Services_Runtime_Services.html}{\textcolor{blue}{\underline{UEFI Specification, Runtime Services}}}.

\section{Casos de bugs de UEFI explotables}
Los bugs en UEFI son particularmente peligrosos porque el firmware se ejecuta antes que el sistema operativo y con privilegios muy altos (equivalente a Ring $-2$ o superior, conceptualmente). Explotarlos puede llevar a ataques muy persistentes y sigilosos (bootkits). Algunos casos notables:

\begin{itemize}[noitemsep]
  \item \textbf{LoJax (2018)}: considerado el primer rootkit UEFI `in the wild', usado por el grupo APT28 (Fancy Bear). Modificaba directamente la SPI flash del firmware para inyectar un módulo malicioso que persistía incluso tras reinstalar el sistema operativo o cambiar el disco duro. Aprovechaba vulnerabilidades y configuraciones inseguras que permitían escritura no autorizada en la flash de firmware.

  \item \textbf{MosaicRegressor (2020)}: framework de spyware basado en UEFI desarrollado por HackingTeam. Utilizaba imágenes de firmware comprometidas para reinstalar el malware en el sistema operativo cada vez que se eliminaba, asegurando persistencia a nivel de firmware.

  \item \textbf{ThinkPwn (2016)}: vulnerabilidad en ciertos firmwares de Lenovo (y potencialmente otros fabricantes) en la gestión de llamadas SMM (System Management Mode). Permitía a un atacante con privilegios de administrador en el SO escalar a SMM, desde donde podía modificar el firmware UEFI protegido.

  \item \textbf{LogoFAIL (2023)}: conjunto de desbordamientos de búfer en parsers de imágenes de logo personalizados usados por muchos fabricantes de UEFI durante la fase DXE (Driver Execution Environment). Un atacante podía cargar una imagen de logo maliciosa que explotara este bug, obteniendo ejecución de código arbitrario en arranque temprano.

  \item \textbf{Vulnerabilidades en drivers UEFI específicos}: de forma recurrente se descubren bugs (por ejemplo, buffer overflows) en drivers de red, USB, almacenamiento, etc. Si un atacante controla los datos procesados por estos drivers (p. ej. un USB malicioso o un paquete de red manipulado), puede desencadenar la vulnerabilidad y ejecutar código con privilegios de firmware.
\end{itemize}

\section{Converged Security and Management Engine (CSME) e Intel Management Engine BIOS Extension (MEBx)}

\textbf{Converged Security and Management Engine (CSME) / Intel Management Engine (ME):}  
Es un subsistema de microcontrolador autónomo integrado en el chipset (Platform Controller Hub, PCH) de la mayoría de las placas base Intel desde 2006/2008. Funciona de forma independiente de la CPU y del sistema operativo, con su propio firmware (basado en MINIX), memoria y acceso directo a hardware crítico (RAM, red, periféricos). Sus principales funciones son:
\begin{itemize}[noitemsep]
  \item \emph{Intel Active Management Technology (AMT):} administración remota fuera de banda (OOB) — encender/apagar, consola remota, incluso si el SO no responde.
  \item \emph{Inicialización temprana de hardware:} parte de la configuración del sistema antes de que el BIOS/UEFI principal tome el control.
  \item \emph{Funciones de seguridad:}  
    \begin{itemize}[noitemsep]
      \item Intel Boot Guard: verifica la firma criptográfica del firmware UEFI.
      \item Intel Platform Trust Technology (PTT): implementación de TPM en firmware.
      \item Gestión de DRM (Protected Audio Video Path, PAVP), etc.
    \end{itemize}
\end{itemize}
Su naturaleza de “caja negra” propietaria con acceso privilegiado ha generado preocupaciones de seguridad; a lo largo de los años se han descubierto vulnerabilidades críticas en el ME/CSME.

\medskip
\textbf{Intel Management Engine BIOS Extension (MEBx):}  
Es el módulo de configuración integrado en el firmware principal (BIOS/UEFI) que permite ajustar las funciones del ME/AMT. Se accede normalmente al presionar \texttt{Ctrl+P} (o la combinación específica del fabricante) durante el POST. Desde MEBx se puede:
\begin{itemize}[noitemsep]
  \item Habilitar/deshabilitar AMT.
  \item Configurar parámetros de red para gestión OOB (dirección IP, VLAN, DNS).
  \item Establecer contraseñas y políticas de acceso al ME.
  \item Activar KVM remoto y otras opciones avanzadas de control.
\end{itemize}

\section{coreboot}

\textbf{¿Qué es coreboot?}  
coreboot es un proyecto de firmware libre y minimalista que reemplaza el BIOS/UEFI propietario. Su filosofía es inicializar únicamente el hardware esencial (CPU, RAM, chipset básico) y luego transferir el control a un \emph{payload} especializado.

\medskip
\textbf{Payloads comunes:}
\begin{itemize}[noitemsep]
  \item \texttt{SeaBIOS}: interfaz BIOS tradicional para compatibilidad con SOs antiguos.
  \item \texttt{TianoCore (EDK II)}: implementación de UEFI completa para SOs modernos.
  \item \texttt{GRUB2} / \texttt{U-Boot}: cargadores de arranque con gran flexibilidad.
  \item \texttt{LinuxBoot}: utiliza el kernel de Linux como payload para entornos Linux “bare-metal”.
\end{itemize}

\medskip
\textbf{Productos que lo incorporan:}
\begin{itemize}[noitemsep]
  \item \emph{Chromebooks} de Google (firmware estándar).
  \item Laptops y desktops de fabricantes enfocados en Linux / privacidad (System76, Purism).
  \item Diversos sistemas embebidos, routers, servidores y dispositivos de red.
  \item Comunidad de porting a placas base de escritorio y portátiles de múltiples marcas.
\end{itemize}

\medskip
\textbf{Ventajas de su utilización:}
\begin{itemize}[noitemsep]
  \item \emph{Velocidad de arranque} muy superior al firmware propietario.
  \item \emph{Flexibilidad y personalización}: elección de payloads y fácil adaptación al hardware.
  \item \emph{Seguridad y transparencia}: código auditables, menor superficie de ataque (aunque a veces requiere \emph{blobs} propietarios para componentes críticos).
  \item \emph{Control total} sobre el proceso de arranque y eliminación de código heredado innecesario.
\end{itemize}

\section{Linker}

\subsection{¿Qué es un linker?}
Un linker es una herramienta fundamental en el proceso de desarrollo de software. Actúa como un “ensamblador” de piezas de código y datos provenientes de diferentes fuentes para crear un único archivo de salida.

\subsection{¿Qué hace?}
Sus tareas principales son:

\begin{itemize}[noitemsep]
  \item \textbf{Combinación de secciones de código y datos:} Los archivos objeto (\texttt{.o}) generados por el ensamblador o el compilador contienen secciones como \texttt{.text} (código), \texttt{.data} (datos inicializados) y \texttt{.bss} (datos no inicializados). El linker toma todas las secciones homónimas de los distintos archivos y las une en una sola sección en el archivo de salida, siguiendo un script de linker o las reglas por defecto.
  
  \item \textbf{Resolución de símbolos:} Cuando el código referencia símbolos (por ejemplo, una función \texttt{print\_char} o una variable \texttt{screen\_buffer}), el linker busca su definición entre todos los archivos objeto y bibliotecas de entrada. Luego sustituye cada uso simbólico por la dirección final donde ese símbolo ha sido colocado. Si falta una definición, se produce un error de “referencia no definida”; si hay definiciones duplicadas, un error de “definición múltiple”.

  \item \textbf{Relocalización:} Los archivos objeto contienen direcciones provisionales. El linker ajusta (o “parchea”) estas direcciones para que apunten a las ubicaciones finales en el ejecutable resultante, teniendo en cuenta la dirección base (por ejemplo, \texttt{0x7C00} en un bootloader). Esto incluye tanto saltos internos como referencias a símbolos externos.

  \item \textbf{Generación del archivo de salida:} Finalmente, escribe el ejecutable final en un formato apropiado (ELF, PE, etc.) o, si se solicita (\texttt{--oformat binary}), en un binario crudo. Este archivo contiene todas las secciones combinadas, los símbolos resueltos y las direcciones relocalizadas.
\end{itemize}

\section{¿Qué es la dirección 0x7C00 y por qué es necesaria?}

La dirección \texttt{0x7C00} es un estándar histórico en la arquitectura x86 que corresponde al punto de memoria donde el BIOS carga el primer sector arrancable (MBR o VBR) de un dispositivo. Su importancia y necesidad en el script del linker se sustenta en varios aspectos:

\begin{itemize}[noitemsep]
  \item \textbf{Convención del BIOS:} Cuando una PC compatible arranca, el firmware (BIOS) lee 512 bytes desde el comienzo del disco o del medio seleccionado y los copia en la dirección física \texttt{0x7C00}. A partir de ahí, transfiere el control de la CPU a ese bloque de código.  

  \item \textbf{Cálculo de direcciones finales:} El código ensamblado incluye referencias a sus propias etiquetas (datos y saltos). Para que esas referencias apunten correctamente durante la ejecución, el linker debe conocer la dirección base donde residirá el bloque completo. Al indicar \texttt{. = 0x7C00} en el script, le decimos al linker “trata este desplazamiento como el origen real”.  

  \item \textbf{Relocalización adecuada:} Gracias a esa directiva, todas las referencias internas (por ejemplo, direcciones de cadenas o puntos de salto) se ajustan en el momento de enlace de modo que, una vez cargado en \texttt{0x7C00}, el programa funcione sin errores de dirección.

  \item \textbf{Evitar desajustes catastróficos:} Si el linker no supiera esta dirección, asumiría una base por defecto (normalmente 0). El BIOS cargaría el código en \texttt{0x7C00}, pero las direcciones binarias incluidas seguirían apuntando al origen equivocado, haciendo que cualquier acceso a datos o saltos termine en memoria incorrecta y provoque un fallo inmediato.
\end{itemize}


\end{document}
